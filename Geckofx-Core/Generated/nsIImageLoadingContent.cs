// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIImageLoadingContent.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// constants.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("0357123d-9224-4d12-a47e-868c32689777")]
	public interface nsIImageLoadingContent : imgINotificationObserver
	{
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Notify(imgIRequest aProxy, int aType, [MarshalAs(UnmanagedType.Interface)] nsIntRect aRect);
		
		/// <summary>
        /// setLoadingEnabled is used to enable and disable loading in
        /// situations where loading images is unwanted.  Note that enabling
        /// loading will *not* automatically trigger an image load.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetLoadingEnabled([MarshalAs(UnmanagedType.U1)] bool aEnabled);
		
		/// <summary>
        /// Returns the image blocking status (@see nsIContentPolicy).  This
        /// will always be an nsIContentPolicy REJECT_* status for cases when
        /// the image was blocked.  This status always refers to the
        /// CURRENT_REQUEST load.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		short GetImageBlockingStatusAttribute();
		
		/// <summary>
        /// Used to register an image decoder observer.  Typically, this will
        /// be a proxy for a frame that wants to paint the image.
        /// Notifications from ongoing image loads will be passed to all
        /// registered observers.  Notifications for all request types,
        /// current and pending, will be passed through.
        ///
        /// @param aObserver the observer to register
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AddNativeObserver(imgINotificationObserver aObserver);
		
		/// <summary>
        /// Used to unregister an image decoder observer.
        ///
        /// @param aObserver the observer to unregister
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveNativeObserver(imgINotificationObserver aObserver);
		
		/// <summary>
        /// Accessor to get the image requests
        ///
        /// @param aRequestType a value saying which request is wanted
        ///
        /// @return the imgIRequest object (may be null, even when no error
        /// is thrown)
        ///
        /// @throws NS_ERROR_UNEXPECTED if the request type requested is not
        /// known
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		imgIRequest GetRequest(int aRequestType);
		
		/// <summary>
        /// Call this function when the request was blocked by any of the
        /// security policies enforced.
        ///
        /// @param aContentDecision the decision returned from nsIContentPolicy
        /// (any of the types REJECT_*)
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetBlockedRequest(short aContentDecision);
		
		/// <summary>
        /// @return true if the current request's size is available.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool CurrentRequestHasSize();
		
		/// <summary>
        /// Used to notify the image loading content node that a frame has been
        /// created.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FrameCreated(System.IntPtr aFrame);
		
		/// <summary>
        /// Used to notify the image loading content node that a frame has been
        /// destroyed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FrameDestroyed(System.IntPtr aFrame);
		
		/// <summary>
        /// Used to find out what type of request one is dealing with (eg
        /// which request got passed through to the imgINotificationObserver
        /// interface of an observer)
        ///
        /// @param aRequest the request whose type we want to know
        ///
        /// @return an enum value saying what type this request is
        ///
        /// @throws NS_ERROR_UNEXPECTED if aRequest is not known
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetRequestType(imgIRequest aRequest);
		
		/// <summary>
        /// Gets the URI of the current request, if available.
        /// Otherwise, returns the last URI that this content tried to load, or
        /// null if there haven't been any such attempts.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIURI GetCurrentURIAttribute();
		
		/// <summary>
        /// loadImageWithChannel allows data from an existing channel to be
        /// used as the image data for this content node.
        ///
        /// @param aChannel the channel that will deliver the data
        ///
        /// @return a stream listener to pump the image data into
        ///
        /// @see imgILoader::loadImageWithChannel
        ///
        /// @throws NS_ERROR_NULL_POINTER if aChannel is null
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIStreamListener LoadImageWithChannel([MarshalAs(UnmanagedType.Interface)] nsIChannel aChannel);
		
		/// <summary>
        /// Enables/disables image state forcing. When |aForce| is true, we force
        /// nsImageLoadingContent::ImageState() to return |aState|. Call again with |aForce|
        /// as false to revert ImageState() to its original behaviour.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ForceImageState([MarshalAs(UnmanagedType.U1)] bool aForce, ulong aState);
		
		/// <summary>
        /// The intrinsic size and width of this content. May differ from actual image
        /// size due to things like responsive image density.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetNaturalWidthAttribute();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetNaturalHeightAttribute();
		
		/// <summary>
        /// Called by layout to announce when the frame associated with this content
        /// has changed its visibility state.
        ///
        /// @param aNewVisibility    The new visibility state.
        /// @param aNonvisibleAction A requested action if the frame has become
        /// nonvisible. If Nothing(), no action is
        /// requested. If DISCARD_IMAGES is specified, the
        /// frame is requested to ask any images it's
        /// associated with to discard their surfaces if
        /// possible.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void OnVisibilityChange(nsISupports aNewVisibility, nsISupports aNonvisibleAction);
	}
	
	/// <summary>nsIImageLoadingContentConsts </summary>
	public class nsIImageLoadingContentConsts
	{
		
		// <summary>
        // Request types.  Image loading content nodes attempt to do atomic
        // image changes when the image url is changed.  This means that
        // when the url changes the new image load will start, but the old
        // image will remain the "current" request until the new image is
        // fully loaded.  At that point, the old "current" request will be
        // discarded and the "pending" request will become "current".
        // </summary>
		public const long UNKNOWN_REQUEST = -1;
		
		// 
		public const long CURRENT_REQUEST = 0;
		
		// 
		public const long PENDING_REQUEST = 1;
	}
}
