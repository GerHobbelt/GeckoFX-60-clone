// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIContentSignatureVerifier.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// An interface for verifying content-signatures, inspired by
    /// https://tools.ietf.org/html/draft-thomson-http-content-signature-00
    /// described here https://github.com/franziskuskiefer/content-signature/tree/pki
    ///
    /// A new signature verifier instance should be created for each signature
    /// verification - you can create these instances with do_CreateInstance.
    ///
    /// There are two ways to use this functionality:
    /// The first allows a signature to be verified all at once by simply calling
    /// verifyContentSignature.
    /// The second allows for streaming; call createContext with the signature
    /// information (and initial data), call update with more data as it becomes
    /// available then, finally, call end to verify the signature.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("45a5fe2f-c350-4b86-962d-02d5aaaa955a")]
	public interface nsIContentSignatureVerifier
	{
		
		/// <summary>
        /// Verifies that the data matches the data that was used to generate the
        /// signature.
        ///
        /// @param aData                   The data to be tested.
        /// @param aContentSignatureHeader The content-signature header,
        /// url-safe base64 encoded.
        /// @param aCertificateChain       The certificate chain to use for verification.
        /// PEM encoded string.
        /// @param aName                   The (host)name for which the end entity must
        ///                                    be valid.
        /// @returns true if the signature matches the data and aCertificateChain is
        /// valid within aContext, false if not.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool VerifyContentSignature([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aData, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aContentSignatureHeader, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aCertificateChain, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aName);
		
		/// <summary>
        /// Creates a context to verify a content signature against data that is added
        /// later with update calls.
        ///
        /// @param aData                   The first chunk of data to be tested.
        /// @param aContentSignatureHeader The signature of the data, url-safe base64
        /// encoded.
        /// @param aCertificateChain       The certificate chain to use for
        /// verification. PEM encoded string.
        /// @param aName                   The (host)name for which the end entity must
        ///                                    be valid.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CreateContext([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aData, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aContentSignatureHeader, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aCertificateChain, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aName);
		
		/// <summary>
        /// Creates a context to verify a content signature against data that is added
        /// later with update calls.
        /// This does not require the caller to download the certificate chain. It's
        /// done internally.
        /// It requires the x5u parameter to be present in aContentSignatureHeader
        ///
        /// NOTE: Callers have to wait for aCallback to return before invoking anything
        /// else. Otherwise the ContentSignatureVerifier will fail.
        ///
        /// @param aCallback               Callback that's invoked when the cert chain
        /// got fetched.
        /// @param aContentSignatureHeader The signature of the data, url-safe base64
        /// encoded, and the x5u value.
        /// @param aName                   The (host)name for which the end entity must
        ///                                    be valid.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CreateContextWithoutCertChain([MarshalAs(UnmanagedType.Interface)] nsIContentSignatureReceiverCallback aCallback, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aContentSignatureHeader, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aName);
		
		/// <summary>
        /// Adds data to the context that was used to generate the signature.
        ///
        /// @param aData        More data to be tested.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Update([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aData);
		
		/// <summary>
        /// Finalises the signature and returns the result of the signature
        /// verification.
        ///
        /// @returns true if the signature matches the data added with createContext
        /// and update, false if not.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool End();
	}
	
	/// <summary>
    /// Callback for nsIContentSignatureVerifier.
    /// { 0x1eb90707, 0xdf59, 0x48b7, \
    /// { 0x9d, 0x42, 0xd8, 0xbf, 0x63, 0x0a, 0xe7, 0x44 } }
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("1eb90707-df59-48b7-9d42-d8bf630ae744")]
	public interface nsIContentSignatureReceiverCallback
	{
		
		/// <summary>
        /// Notification callback that's called by nsIContentSignatureVerifier when
        /// the cert chain is downloaded.
        /// If download and initialisation were successful, successful is true,
        /// otherwise false. If successful is false, the verification must be aborted.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ContextCreated([MarshalAs(UnmanagedType.U1)] bool successful);
	}
}
