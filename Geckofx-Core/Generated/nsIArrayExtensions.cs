// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIArrayExtensions.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// Helper interface for allowing scripts to treat nsIArray instances as if
    /// they were nsISupportsArray instances while iterating.
    ///
    /// nsISupportsArray is convenient to iterate over in JavaScript:
    ///
    /// for (let i = 0; i < array.Count(); ++i) {
    /// let elem = array.GetElementAt(i);
    /// ...
    /// }
    ///
    /// but doing the same with nsIArray is somewhat less convenient, since
    /// queryElementAt is not nearly so nice to use from JavaScript.  So we provide
    /// this extension interface so interfaces that currently return
    /// nsISupportsArray can start returning nsIArrayExtensions and all JavaScript
    /// should Just Work. Eventually we'll roll this interface into nsIArray
    /// itself, possibly getting rid of the Count() method, as it duplicates
    /// nsIArray functionality.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("261d442e-050c-453d-8aaa-b3f23bcc528b")]
	public interface nsIArrayExtensions : nsIArray
	{
		
		/// <summary>
        /// length
        ///
        /// number of elements in the array.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new uint GetLengthAttribute();
		
		/// <summary>
        /// queryElementAt()
        ///
        /// Retrieve a specific element of the array, and QueryInterface it
        /// to the specified interface. null is a valid result for
        /// this method, but exceptions are thrown in other circumstances
        ///
        /// @param index position of element
        /// @param uuid the IID of the requested interface
        /// @param result the object, QI'd to the requested interface
        ///
        /// @throws NS_ERROR_NO_INTERFACE when an entry exists at the
        /// specified index, but the requested interface is not
        /// available.
        /// @throws NS_ERROR_ILLEGAL_VALUE when index > length-1
        ///
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.IntPtr QueryElementAt(uint index, ref System.Guid uuid);
		
		/// <summary>
        /// indexOf()
        ///
        /// Get the position of a specific element. Note that since null is
        /// a valid input, exceptions are used to indicate that an element
        /// is not found.
        ///
        /// @param startIndex The initial element to search in the array
        /// To start at the beginning, use 0 as the
        /// startIndex
        /// @param element    The element you are looking for
        /// @returns a number >= startIndex which is the position of the
        /// element in the array.
        /// @throws NS_ERROR_FAILURE if the element was not in the array.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new uint IndexOf(uint startIndex, [MarshalAs(UnmanagedType.Interface)] nsISupports element);
		
		/// <summary>
        /// enumerate the array
        ///
        /// @returns a new enumerator positioned at the start of the array
        /// @throws NS_ERROR_FAILURE if the array is empty (to make it easy
        /// to detect errors), or NS_ERROR_OUT_OF_MEMORY if out of memory.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsISimpleEnumerator Enumerate();
		
		/// <summary>
        /// Count()
        ///
        /// Retrieves the length of the array. This is an alias for the
        /// |nsIArray.length| attribute.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint Count();
		
		/// <summary>
        /// GetElementAt()
        ///
        /// Retrieve a specific element of the array. null is a valid result for
        /// this method.
        ///
        /// Note: If the index is out of bounds null will be returned.
        /// This differs from the behavior of nsIArray.queryElementAt() which
        /// will throw if an invalid index is specified.
        ///
        /// @param index position of element
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISupports GetElementAt(uint index);
	}
}
