// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsITelemetry.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    ///This Source Code Form is subject to the terms of the Mozilla Public
    /// License, v. 2.0. If a copy of the MPL was not distributed with this
    /// file, You can obtain one at http://mozilla.org/MPL/2.0/. </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("3d3b9075-5549-4244-9c08-b64fefa1dd60")]
	public interface nsIFetchTelemetryDataCallback
	{
		
		/// <summary>
        ///This Source Code Form is subject to the terms of the Mozilla Public
        /// License, v. 2.0. If a copy of the MPL was not distributed with this
        /// file, You can obtain one at http://mozilla.org/MPL/2.0/. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Complete();
	}
	
	/// <summary>nsITelemetry </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("273d2dd0-6c63-475a-b864-cb65160a1909")]
	public interface nsITelemetry
	{
		
		/// <summary>
        /// Serializes the histograms from the given dataset to a JSON-style object.
        /// The returned structure looks like:
        /// { process1: {name1: {histogramData1}, name2:{histogramData2}...}}
        ///
        /// Where histogramDataN has the following properties:
        /// min - minimum bucket size
        /// max - maximum bucket size
        /// histogram_type - HISTOGRAM_EXPONENTIAL, HISTOGRAM_LINEAR, HISTOGRAM_BOOLEAN,
        /// HISTOGRAM_FLAG, HISTOGRAM_COUNT, or HISTOGRAM_CATEGORICAL
        /// counts - array representing contents of the buckets in the histogram
        /// ranges - array with calculated bucket sizes
        /// sum - sum of the bucket contents
        ///
        /// @param aDataset DATASET_RELEASE_CHANNEL_OPTOUT or DATASET_RELEASE_CHANNEL_OPTIN.
        /// @param aSubsession Whether to return the internally-duplicated subsession histograms
        /// @param aClear Whether to clear out the subsession histograms after snapshotting (only works if aSubsession is true)
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal SnapshotHistograms(uint aDataset, [MarshalAs(UnmanagedType.U1)] bool aSubsession, [MarshalAs(UnmanagedType.U1)] bool aClear, System.IntPtr jsContext);
		
		/// <summary>
        /// The amount of time, in milliseconds, that the last session took
        /// to shutdown.  Reads as 0 to indicate failure.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetLastShutdownDurationAttribute();
		
		/// <summary>
        /// The number of failed profile lock attempts that have occurred prior to
        /// successfully locking the profile
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetFailedProfileLockCountAttribute();
		
		/// <summary>
        /// An object containing information about slow SQL statements.
        ///
        /// {
        /// mainThread: { "sqlString1": [<hit count>, <total time>], "sqlString2": [...], ... },
        /// otherThreads: { "sqlString3": [<hit count>, <total time>], "sqlString4": [...], ... }
        /// }
        ///
        /// where:
        /// mainThread: Slow statements that executed on the main thread
        /// otherThreads: Slow statements that executed on a non-main thread
        /// sqlString - String of the offending statement (see note)
        /// hit count - The number of times this statement required longer than the threshold time to execute
        /// total time - The sum of all execution times above the threshold time for this statement
        ///
        /// Note that dynamic SQL strings and SQL strings executed against addon DBs could contain private information.
        /// This property represents such SQL as aggregate database-level stats and the sqlString contains the database
        /// filename instead.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetSlowSQLAttribute(System.IntPtr jsContext);
		
		/// <summary>
        /// See slowSQL above.
        ///
        /// An object containing full strings of every slow SQL statement if toolkit.telemetry.debugSlowSql = true
        /// The returned SQL strings may contain private information and should not be reported to Telemetry.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetDebugSlowSQLAttribute(System.IntPtr jsContext);
		
		/// <summary>
        /// An object containing information about Webrtc related stats. For now it
        /// only contains local and remote ICE candidates avaiable when a Webrtc
        /// PeerConnection gets terminated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetWebrtcStatsAttribute(System.IntPtr jsContext);
		
		/// <summary>
        /// A number representing the highest number of concurrent threads
        /// reached during this session.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetMaximalNumberOfConcurrentThreadsAttribute();
		
		/// <summary>
        /// An array of chrome hang reports. Each element is a hang report represented
        /// as an object containing the hang duration, call stack PCs and information
        /// about modules in memory.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetChromeHangsAttribute(System.IntPtr jsContext);
		
		/// <summary>
        /// Record the current thread's call stack on demand. Note that, the stack is
        /// only captured at the first call. All subsequent calls result in incrementing
        /// the capture counter without doing actual stack unwinding.
        ///
        /// @param aKey - A user defined key associated with the captured stack.
        ///
        /// NOTE: Unwinding call stacks is an expensive operation performance-wise.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CaptureStack([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase name);
		
		/// <summary>
        /// Returns a snapshot of captured stacks. The data has the following structure:
        ///
        /// {
        /// "memoryMap": [
        /// ["wgdi32.pdb", "08A541B5942242BDB4AEABD8C87E4CFF2"],
        /// ["igd10iumd32.pdb", "D36DEBF2E78149B5BE1856B772F1C3991"],
        /// ... other entries in the format ["module name", "breakpad identifier"] ...
        /// ],
        /// "stacks": [
        /// [
        /// [
        /// 0, // the module index or -1 for invalid module indices
        /// 190649 // the offset of this program counter in its module or an absolute pc
        /// ],
        /// [1, 2540075],
        /// ... other frames ...
        /// ],
        /// ... other stacks ...
        /// ],
        /// "captures": [["string-key", stack-index, count], ... ]
        /// }
        ///
        /// @param clear Whether to clear out the subsession histograms after taking a snapshot.
        ///
        /// @return A snapshot of captured stacks.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal SnapshotCapturedStacks([MarshalAs(UnmanagedType.U1)] bool clear, System.IntPtr jsContext);
		
		/// <summary>
        /// Asynchronously get an array of the modules loaded in the process.
        ///
        /// The data has the following structure:
        ///
        /// [
        /// {
        /// "name": <string>, // Name of the module file (e.g. xul.dll)
        /// "version": <string>, // Version of the module
        /// "debugName": <string>, // ID of the debug information file
        /// "debugID": <string>, // Name of the debug information file
        /// "certSubject": <string>, // Name of the organization that signed the binary (Optional, only defined when present)
        /// },
        /// ...
        /// ]
        ///
        /// @return A promise that resolves to an array of modules or rejects with
        ///             NS_ERROR_FAILURE on failure.
        /// @throws NS_ERROR_NOT_IMPLEMENTED if the Gecko profiler is not enabled.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISupports GetLoadedModules(System.IntPtr jsContext);
		
		/// <summary>
        /// An object with two fields: memoryMap and stacks.
        /// * memoryMap is a list of loaded libraries.
        /// * stacks is a list of stacks. Each stack is a list of pairs of the form
        /// [moduleIndex, offset]. The moduleIndex is an index into the memoryMap and
        /// offset is an offset in the library at memoryMap[moduleIndex].
        /// This format is used to make it easier to send the stacks to the
        /// symbolication server.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetLateWritesAttribute(System.IntPtr jsContext);
		
		/// <summary>
        /// Create and return a histogram registered in TelemetryHistograms.h.
        ///
        /// @param id - unique identifier from TelemetryHistograms.h
        /// The returned object has the following functions:
        /// add(int) - Adds an int value to the appropriate bucket
        /// snapshot() - Returns a snapshot of the histogram with the same data fields as in histogramSnapshots()
        /// clear() - Zeros out the histogram's buckets and sum. This is intended to be only used in tests.
        /// dataset() - identifies what dataset this is in: DATASET_RELEASE_CHANNEL_OPTOUT or ...OPTIN.
        /// This is intended to be only used in tests.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetHistogramById([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase id, System.IntPtr jsContext);
		
		/// <summary>
        /// Serializes the keyed histograms from the given dataset to a JSON-style object.
        /// The returned structure looks like:
        /// { process1: {name1: {histogramData1}, name2:{histogramData2}...}}
        ///
        /// @param aDataset DATASET_RELEASE_CHANNEL_OPTOUT or DATASET_RELEASE_CHANNEL_OPTIN.
        /// @param aSubsession Whether to return the internally-duplicated subsession keyed histograms
        /// @param aClear Whether to clear out the subsession keyed histograms after snapshotting (only works if aSubsession is true)
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal SnapshotKeyedHistograms(uint aDataset, [MarshalAs(UnmanagedType.U1)] bool aSubsession, [MarshalAs(UnmanagedType.U1)] bool aClear, System.IntPtr jsContext);
		
		/// <summary>
        /// Create and return a histogram registered in TelemetryHistograms.h.
        ///
        /// @param id - unique identifier from TelemetryHistograms.h
        /// The returned object has the following functions:
        /// add(string key, [optional] int) - Add an int value to the histogram for that key. If no histogram for that key exists yet, it is created.
        /// snapshot([optional] string key) - If key is provided, returns a snapshot for the histogram with that key or null. If key is not provided, returns the snapshots of all the registered keys in the form {key1: snapshot1, key2: snapshot2, ...}.
        /// keys() - Returns an array with the string keys of the currently registered histograms
        /// clear() - Clears the registered histograms from this.
        /// This is intended to be only used in tests.
        /// dataset() - identifies what dataset this is in: DATASET_RELEASE_CHANNEL_OPTOUT or ...OPTIN.
        /// This is intended to be only used in tests.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetKeyedHistogramById([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase id, System.IntPtr jsContext);
		
		/// <summary>
        /// A flag indicating if Telemetry can record base data (FHR data). This is true if the
        /// FHR data reporting service or self-support are enabled.
        ///
        /// In the unlikely event that adding a new base probe is needed, please check the data
        /// collection wiki at https://wiki.mozilla.org/Firefox/Data_Collection and talk to the
        /// Telemetry team.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetCanRecordBaseAttribute();
		
		/// <summary>
        /// A flag indicating if Telemetry can record base data (FHR data). This is true if the
        /// FHR data reporting service or self-support are enabled.
        ///
        /// In the unlikely event that adding a new base probe is needed, please check the data
        /// collection wiki at https://wiki.mozilla.org/Firefox/Data_Collection and talk to the
        /// Telemetry team.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetCanRecordBaseAttribute([MarshalAs(UnmanagedType.U1)] bool aCanRecordBase);
		
		/// <summary>
        /// A flag indicating if Telemetry is allowed to record extended data. Returns false if
        /// the user hasn't opted into "extended Telemetry" on the Release channel, when the
        /// user has explicitly opted out of Telemetry on Nightly/Aurora/Beta or if manually
        /// set to false during tests.
        ///
        /// Set this to false in tests to disable gathering of extended telemetry statistics.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetCanRecordExtendedAttribute();
		
		/// <summary>
        /// A flag indicating if Telemetry is allowed to record extended data. Returns false if
        /// the user hasn't opted into "extended Telemetry" on the Release channel, when the
        /// user has explicitly opted out of Telemetry on Nightly/Aurora/Beta or if manually
        /// set to false during tests.
        ///
        /// Set this to false in tests to disable gathering of extended telemetry statistics.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetCanRecordExtendedAttribute([MarshalAs(UnmanagedType.U1)] bool aCanRecordExtended);
		
		/// <summary>
        /// A flag indicating whether Telemetry is recording release data, which is a
        /// smallish subset of our usage data that we're prepared to handle from our
        /// largish release population.
        ///
        /// This is true most of the time.
        ///
        /// This does not indicate whether Telemetry will send any data. That is
        /// governed by user preference and other mechanisms.
        ///
        /// You may use this to determine if it's okay to record your data.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetCanRecordReleaseDataAttribute();
		
		/// <summary>
        /// A flag indicating whether Telemetry is recording prerelease data, which is
        /// a largish amount of usage data that we're prepared to handle from our
        /// smallish pre-release population.
        ///
        /// This is true on pre-release branches of Firefox.
        ///
        /// This does not indicate whether Telemetry will send any data. That is
        /// governed by user preference and other mechanisms.
        ///
        /// You may use this to determine if it's okay to record your data.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetCanRecordPrereleaseDataAttribute();
		
		/// <summary>
        /// A flag indicating whether Telemetry can submit official results (for base or extended
        /// data). This is true on official, non-debug builds with built in support for Mozilla
        /// Telemetry reporting.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsOfficialTelemetryAttribute();
		
		/// <summary>
        /// Enable/disable recording for this histogram at runtime.
        /// Recording is enabled by default, unless listed at kRecordingInitiallyDisabledIDs[].
        /// Name must be a valid Histogram identifier, otherwise an assertion will be triggered.
        ///
        /// @param id - unique identifier from histograms.json
        /// @param enabled - whether or not to enable recording from now on.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetHistogramRecordingEnabled([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase id, [MarshalAs(UnmanagedType.U1)] bool enabled);
		
		/// <summary>
        /// Read data from the previous run. After the callback is called, the last
        /// shutdown time is available in lastShutdownDuration and any late
        /// writes in lateWrites.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AsyncFetchTelemetryData([MarshalAs(UnmanagedType.Interface)] nsIFetchTelemetryDataCallback aCallback);
		
		/// <summary>
        /// Get statistics of file IO reports, null, if not recorded.
        ///
        /// The statistics are returned as an object whose propoerties are the names
        /// of the files that have been accessed and whose corresponding values are
        /// arrays of size three, representing startup, normal, and shutdown stages.
        /// Each stage's entry is either null or an array with the layout
        /// [total_time, #creates, #reads, #writes, #fsyncs, #stats]
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetFileIOReportsAttribute(System.IntPtr jsContext);
		
		/// <summary>
        /// Return the number of milliseconds since process start using monotonic
        /// timestamps (unaffected by system clock changes).
        /// @throws NS_ERROR_NOT_AVAILABLE if TimeStamp doesn't have the data.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double MsSinceProcessStart();
		
		/// <summary>
        /// Time since the system wide epoch. This is not a monotonic timer but
        /// can be used across process boundaries.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double MsSystemNow();
		
		/// <summary>
        /// Adds the value to the given scalar.
        ///
        /// @param aName The scalar name.
        /// @param aValue The numeric value to add to the scalar. Only unsigned integers supported.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ScalarAdd([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aName, ref Gecko.JsVal aValue, System.IntPtr jsContext);
		
		/// <summary>
        /// Sets the scalar to the given value.
        ///
        /// @param aName The scalar name.
        /// @param aValue The value to set the scalar to. If the type of aValue doesn't match the
        /// type of the scalar, the function will fail. For scalar string types, the this
        /// is truncated to 50 characters.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ScalarSet([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aName, ref Gecko.JsVal aValue, System.IntPtr jsContext);
		
		/// <summary>
        /// Sets the scalar to the maximum of the current and the passed value.
        ///
        /// @param aName The scalar name.
        /// @param aValue The numeric value to set the scalar to. Only unsigned integers supported.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ScalarSetMaximum([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aName, ref Gecko.JsVal aValue, System.IntPtr jsContext);
		
		/// <summary>
        /// Serializes the scalars from the given dataset to a JSON-style object and resets them.
        /// The returned structure looks like:
        /// {"process": {"category1.probe":1,"category1.other_probe":false,...}, ... }.
        ///
        /// @param aDataset DATASET_RELEASE_CHANNEL_OPTOUT or DATASET_RELEASE_CHANNEL_OPTIN.
        /// @param [aClear=false] Whether to clear out the scalars after snapshotting.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal SnapshotScalars(uint aDataset, [MarshalAs(UnmanagedType.U1)] bool aClear, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Adds the value to the given keyed scalar.
        ///
        /// @param aName The scalar name.
        /// @param aKey The key name.
        /// @param aValue The numeric value to add to the scalar. Only unsigned integers supported.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void KeyedScalarAdd([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aKey, ref Gecko.JsVal aValue, System.IntPtr jsContext);
		
		/// <summary>
        /// Sets the keyed scalar to the given value.
        ///
        /// @param aName The scalar name.
        /// @param aKey The key name.
        /// @param aValue The value to set the scalar to. If the type of aValue doesn't match the
        /// type of the scalar, the function will fail.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void KeyedScalarSet([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aKey, ref Gecko.JsVal aValue, System.IntPtr jsContext);
		
		/// <summary>
        /// Sets the keyed scalar to the maximum of the current and the passed value.
        ///
        /// @param aName The scalar name.
        /// @param aKey The key name.
        /// @param aValue The numeric value to set the scalar to. Only unsigned integers supported.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void KeyedScalarSetMaximum([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aName, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.AStringMarshaler")] nsAStringBase aKey, ref Gecko.JsVal aValue, System.IntPtr jsContext);
		
		/// <summary>
        /// Serializes the keyed scalars from the given dataset to a JSON-style object and
        /// resets them.
        /// The returned structure looks like:
        /// { "process": { "category1.probe": { "key_1": 2, "key_2": 1, ... }, ... }, ... }
        ///
        /// @param aDataset DATASET_RELEASE_CHANNEL_OPTOUT or DATASET_RELEASE_CHANNEL_OPTIN.
        /// @param [aClear=false] Whether to clear out the scalars after snapshotting.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal SnapshotKeyedScalars(uint aDataset, [MarshalAs(UnmanagedType.U1)] bool aClear, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Resets all the stored scalars. This is intended to be only used in tests.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearScalars();
		
		/// <summary>
        /// Immediately sends any Telemetry batched on this process to the parent
        /// process. This is intended only to be used on process shutdown.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FlushBatchedChildTelemetry();
		
		/// <summary>
        /// Record an event in Telemetry.
        ///
        /// @param aCategory The category name.
        /// @param aMethod The method name.
        /// @param aMethod The object name.
        /// @param aValue An optional string value to record.
        /// @param aExtra An optional object of the form (string -> string).
        /// It should only contain registered extra keys.
        ///
        /// @throws NS_ERROR_INVALID_ARG When trying to record an unknown event.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RecordEvent([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aCategory, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aMethod, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aObject, ref Gecko.JsVal aValue, ref Gecko.JsVal extra, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Enable recording of events in a category.
        /// Events default to recording disabled. This allows to toggle recording for all events
        /// in the specified category.
        ///
        /// @param aCategory The category name.
        /// @param aEnabled Whether recording is enabled for events in that category.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetEventRecordingEnabled([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aCategory, [MarshalAs(UnmanagedType.U1)] bool aEnabled);
		
		/// <summary>
        /// Serializes the recorded events to a JSON-appropriate array and optionally resets them.
        /// The returned structure looks like this:
        /// [
        /// // [timestamp, category, method, object, stringValue, extraValues]
        /// [43245, "category1", "method1", "object1", "string value", null],
        /// [43258, "category1", "method2", "object1", null, {"key1": "string value"}],
        /// ...
        /// ]
        ///
        /// @param aDataset DATASET_RELEASE_CHANNEL_OPTOUT or DATASET_RELEASE_CHANNEL_OPTIN.
        /// @param [aClear=false] Whether to clear out the scalars after snapshotting.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal SnapshotEvents(uint aDataset, [MarshalAs(UnmanagedType.U1)] bool aClear, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Register new events to record them from addons. This allows registering multiple
        /// events for a category. They will be valid only for the current Firefox session.
        /// Note that events shipping in Firefox should be registered in Events.yaml.
        ///
        /// @param aCategory The unique category the events are registered in.
        /// @param aEventData An object that contains registration data for 1-N events of the form:
        /// {
        /// "categoryName": {
        /// "methods": ["test1"],
        /// "objects": ["object1"],
        /// "record_on_release": false,
        /// "extra_keys": ["key1", "key2"], // optional
        /// "expired": false // optional, defaults to false.
        /// },
        /// ...
        /// }
        /// @param aEventData.<name>.methods List of methods for this event entry.
        /// @param aEventData.<name>.objects List of objects for this event entry.
        /// @param aEventData.<name>.extra_keys Optional, list of allowed extra keys for this event entry.
        /// @param aEventData.<name>.record_on_release Optional, whether to record this data on release.
        /// Defaults to false.
        /// @param aEventData.<name>.expired Optional, whether this event entry is expired. This allows
        /// recording it without error, but it will be discarded. Defaults to false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RegisterEvents([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aCategory, ref Gecko.JsVal aEventData, System.IntPtr jsContext);
		
		/// <summary>
        /// Parent process only. Register new scalars to record them from addons. This
        /// allows registering multiple scalars for a category. They will be valid only for
        /// the current Firefox session.
        /// Note that scalars shipping in Firefox should be registered in Scalars.yaml.
        ///
        /// @param aCategoryName The unique category the scalars are registered in.
        /// @param aScalarData An object that contains registration data for multiple scalars in the form:
        /// {
        /// "sample_scalar": {
        /// "kind": Ci.nsITelemetry.SCALAR_TYPE_COUNT,
        /// "keyed": true, //optional, defaults to false
        /// "record_on_release: true, // optional, defaults to false
        /// "expired": false // optional, defaults to false.
        /// },
        /// ...
        /// }
        /// @param aScalarData.<name>.kind One of the scalar types defined in this file (SCALAR_TYPE_*)
        /// @param aScalarData.<name>.keyed Optional, whether this is a keyed scalar or not. Defaults to false.
        /// @param aScalarData.<name>.record_on_release Optional, whether to record this data on release.
        /// Defaults to false.
        /// @param aScalarData.<name>.expired Optional, whether this scalar entry is expired. This allows
        /// recording it without error, but it will be discarded. Defaults to false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RegisterScalars([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aCategoryName, ref Gecko.JsVal aScalarData, System.IntPtr jsContext);
		
		/// <summary>
        /// Parent process only. Register dynamic builtin scalars. The parameters
        /// have the same meaning as the usual |registerScalars| function.
        ///
        /// This function is only meant to be used to support the "artifact build"/
        /// "built faster" developers by allowing to add new scalars without rebuilding
        /// the C++ components including the headers files.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RegisterBuiltinScalars([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aCategoryName, ref Gecko.JsVal aScalarData, System.IntPtr jsContext);
		
		/// <summary>
        /// Resets all the stored events. This is intended to be only used in tests.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearEvents();
	}
	
	/// <summary>nsITelemetryConsts </summary>
	public class nsITelemetryConsts
	{
		
		// <summary>
        // Histogram types:
        // HISTOGRAM_EXPONENTIAL - buckets increase exponentially
        // HISTOGRAM_LINEAR - buckets increase linearly
        // HISTOGRAM_BOOLEAN - For storing 0/1 values
        // HISTOGRAM_FLAG - For storing a single value; its count is always == 1.
        // HISTOGRAM_COUNT - For storing counter values without bucketing.
        // HISTOGRAM_CATEGORICAL - For storing enumerated values by label.
        // </summary>
		public const ulong HISTOGRAM_EXPONENTIAL = 0;
		
		// 
		public const ulong HISTOGRAM_LINEAR = 1;
		
		// 
		public const ulong HISTOGRAM_BOOLEAN = 2;
		
		// 
		public const ulong HISTOGRAM_FLAG = 3;
		
		// 
		public const ulong HISTOGRAM_COUNT = 4;
		
		// 
		public const ulong HISTOGRAM_CATEGORICAL = 5;
		
		// <summary>
        // Scalar types:
        // SCALAR_TYPE_COUNT - for storing a numeric value
        // SCALAR_TYPE_STRING - for storing a string value
        // SCALAR_TYPE_BOOLEAN - for storing a boolean value
        // </summary>
		public const ulong SCALAR_TYPE_COUNT = 0;
		
		// 
		public const ulong SCALAR_TYPE_STRING = 1;
		
		// 
		public const ulong SCALAR_TYPE_BOOLEAN = 2;
		
		// <summary>
        // Dataset types:
        // DATASET_RELEASE_CHANNEL_OPTOUT - the basic dataset that is on-by-default on all channels
        // DATASET_RELEASE_CHANNEL_OPTIN - the extended dataset that is opt-in on release,
        // opt-out on pre-release channels.
        // </summary>
		public const ulong DATASET_RELEASE_CHANNEL_OPTOUT = 0;
		
		// 
		public const ulong DATASET_RELEASE_CHANNEL_OPTIN = 1;
	}
}
